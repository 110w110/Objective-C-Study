# 상속과 클래스 및 객체 타입과 동적 결합

## **상속**

기존에 정의된 Class의 기능을 일부 확장하거나 변경해야하는 경우에 상속을 사용한다.

상속의 모체가 되는 Class를 Super Class 라고 하고, 새롭게 만들어지는 Class를 Sub Class라고 한다.

**Sub Class의 생성**으로 사용할 수 있는 기능은 아래와 같다.

1. 새로운 메소드를 추가한다.
2. 새로운 인스턴스 변수를 추가한다.
3. Super Class의 메소드를 다른 정의 내용으로 교체한다. (**Override**)

Cocoa 환경에서는 **NSObject**가 최상위의 Root Class이다.

## **상속의 선언과 활용**

상속 관계의 선언은 **Sub Class**의 **Interface**에서 선언한다.

```
@interface 클래스명 : 슈퍼클래스명 {
	인스턴스 변수 선언
}
- 메소드 선언
@end
```

---

인스턴스 변수가 없다면 중괄호 블럭을 비워두거나 아예 삭제해도 된다.

상속을 통해 새롭게 추가할 변수나 메소드를 작성하면 된다.

만약 Override로 메소드를 변경했다면 주석으로 표시해주는 것이 좋다.

만약 상속 관계에서 상위에 존재하는 Class의 메소드를 사용하고 싶다면 **super**라는 키워드를 사용하면 된다.

**super는 self와 달리 특정 객체를 나타내는 것은 아니므로 변수에 대입하거나 리턴하는 것은 불가능하다.**

![Untitled](https://github.com/110w110/Objective-C-Study/assets/87888411/e2657dd4-4e9c-4c29-bc41-458045ee2e16)


슈퍼클래스의 이니셜라이저를 먼저 실행하고 서브클래스의 이니셜라이저를 올바르게 실행하기 위해 아래와 같이 이니셜라이저를 작성한다.

```
self = [super init];    // 슈퍼클래스의 이니셜라이저를 호출
    if (self) {             //슈퍼클래스에서 인스턴스가 반환된 경우에는 (nil이 아니면) 아래의 서브클래스 초기화 코드 실행
        width = w;
        height = h;
    }
    return self;
```

---

### **참고) Boolean 값을 콘솔에 출력할 때는 삼항연산자를 활용하여 출력한다.**

*22.12.21 추가)*

*Obj-C에서 **BOOL 타입**은 true / false 말고 **Yes / No** 로 많이 사용한다고 한다.*

### **참고) autoreleasepool : 블럭 내부에서 생성된 객체를 자동으로 메모리에서 release 해주는 기능**

- autoreleasepool 안에서 생성된 객체는 블럭이 끝남과 동시에 자동으로 메모리에서 release 된다.
- main 함수에서 기본으로 작성되어 있는 @autoreleasepool은 main()의 종료와 함께 프로그램도 종료되므로 상황에 따라 필요 없을 수도 있다.
- 코드 블럭 내에서 적절하게 배치하여 사용하면 비효율적으로 사용되는 메모리를 관리할 수 있을 것 같다.

## **지역 메소드**

구현 코드 안에서만 활용하기 위한 메소드를 지역적으로 활용할 수 있다.

인터페이스에서 따로 메소드 선언을 해줄 필요가 없다.

~~상속 시 하위 클래스에서 의도치 않은 override가 발생할 수 있으므로 반드시 **고유한 prefix**를 활용하는 것이 권장된다.~~ (테스트 해보니 하위 클래스에서 상위 클래스의 지역 메소드에 접근을 못하는 것 같다.)

~~또한 인터페이스에서 함수의 원형을 전방 선언하지 않는 경우 컴파일 에러가 발생하므로 **정의하는 순서**에 주의해야 한다.~~ (직접 테스트 해보니까 상관 없는 것 같다. 바뀐걸까?)

![Untitled2](https://github.com/110w110/Objective-C-Study/assets/87888411/a7fd27d4-d470-4349-bdbe-1929fe6b2175)

## **지정 이니셜라이저 (designated initializer)**

하나의 클래스에는 다양한 이니셜라이저가 존재할 수 있지만 **인스턴스 초기화를 위해 반드시 실행되어야 하는 메소드**를 지정 이니셜라이저라고 한다.

지정 이니셜라이저는 하나 이상 존재할 수 있다.

지정 이니셜라이저가 아닌 이니셜라이저는 **보조 이니셜라이저**라고도 한다.

**하위 클래스의 지정 이니셜라이저는 슈퍼 클래스의 지정 이니셜라이저를 호출하도록 정의해야 한다.**

(22.12.21 추가 그러니까 모든 상속 클래스 관계에서 특정 이니셜라이저를 지정 이니셜라이저로 설정해야 하는 것이 아니라, 로직 상 특정한 이니셜라이저를 필수로 사용해야 하는 경우에는 표시를 하고 사용하는 것이 맞다는 것. 따라서 타인의 클래스를 상속하여 쓸 때는 도큐먼트나 주석을 참고하여 확인해야 한다.)

최상위 클래스인 NSObject의 지정 이니셜라이저는 init이다.

지정 이니셜라이저는 별도의 문법으로 정해지는 것이 아니므로 **인터페이스에 주석으로 명시할 것**이 권장된다.

*22.12.21 추가)*

*지정 이니셜라이저를 **매크로 구문**을 통해 지정해줄 수 있다.*

***NS_DESIGNATED_INITIALIZER;***

## **동적 바인딩 (Dynamic Binding)**

Obj-C에서는 어떤 객체가 어떤 메소드를 호출할 때 **그 메시지를 처리할 수 있는지 없는지를 컴파일 시점에 판단하지 않는다**.

이것은 실제로 메시지가 처리될 때 확인되는데 Obj-C에서의 동적바인딩은 이처럼 **runtime 시간에 호출할 메서드가 결정되는 것**을 의미한다.

이 때문에 같은 이름의 메소드를 가지고 있다면, 클래스에 관계 없이 프로그램의 흐름에 따라 동적으로 메소드를 호출할 수 있게 되고, 이러한 다형성의 원리에 따라 유연한 프로그램이 가능하다.

- **동적타이핑** : 프로그램이 실행 될 때 객체가 타입이 결정된다.
- **동적바인딩** : 프로그램이 실행 될 때 어떤 객체의 메소드가 호출될 지 결정된다.

*22.12.22 추가)*

*아래의 예시에서 만약 '개'라는 클래스의 객체를 생성했다면, 이동(), 달리다(), 짖다() 등 다양한 메서드를 활용할 수 있지만 날다()라는 메서드는 컴파일 시점에서 에러가 발생할 것이다.*

*하지만 '개'라는 클래스의 객체를 id에 담아서 날다()라는 메서드를 호출하면, 컴파일러 입장에서는 그 id에 어떤 클래스의 객체가 있을지 모르기 때문에 사전에 차단하지 않는다.*

*실제로 '개'는 날 수 없기 때문에 런타임에서는 에러가 발생할 것이다.*

## **클래스를 타입으로 쓰기**

Obj-C에서는 클래스를 타입으로 사용할 수 있다.

id 타입에 담을 수도 있지만 원치 않은 결과를 막기 위해서는 **특정 클래스로 명시하는 것이 좋다**.

객체는 포인터로 표현하면 되는데, 이에 따라 **nil 값에 대한 대응**도 필요하다.

**nil 값이 0**이라는 것을 이용해서 아래와 같이 처리할 수 있다.

```
if ([클래스명 메시지명:인수] != nil) ...

또는

if ([클래스명 메시지명:인수]) ...
```

---

### **참고) Obj-C에서는 C언어와 같이 관계연산자에서 전방에 위치한 관계식이 전체 논리 결과를 결정 했다면 이후의 논리식은 실행되지 않는다.**

## **메시지 인수와 리턴 값의 타입에 대하여**

Obj-C에서 프로그램 내에서의 메서드 호출 시에는 인수나 리턴 값의 타입을 알 수가 없다.

따라서 셀렉터가 같지만 인수나 리턴 값의 타입이 다르면 런타임 전까지는 어떤 메소드가 호출될 지 알 수가 없다.

예를 들어 아래와 같이 메세지의 셀럭터는 동일하지만 시그니쳐가 다른(인수나 리턴값의 타입은 다른) 메소드가 존재할 수 있다.

```
@interface ClassA : NSObject
-(int)myFunc;
@end

@interface ClassB : NSObject
-(float)myFunc;
@end

@interface ClassDerivedA : ClassA
-(const char *)myFunc;
@end
```

---

이 경우에 ClassA와 ClassB는 서로 다른 클래스이므로 큰 문제가 없을 수 있지만, ClassA와 ClassDerivedA는 서로 상속의 관계에 있기 때문에 ClassDerived에서 생성된 인스턴스가 (int)myFunc를 호출하게 될 리스크가 존재한다.

이런 경우에는 의도되지 않은 리턴 타입에 의해 런타임에 에러가 발생할 수 있기 때문에 기본적으로는 **같은 셀렉터를 가지는 메시지는 인수나 리턴 값의 타입을 맞춰주는 것이 좋다**. (언어의 유연성을 잃을 수는 있다)

## **다른 클래스에 대한 전방 선언**

다른 클래스를 인수나 리턴 값으로 쓰기 위해서는 **그 클래스의 헤더 파일을 임포트** 해야한다.

하지만 전체 헤더 파일을 모두 임포트 할 필요 없이 아래와 같은 방식으로 클래스의 식별자만 전방 선언할 수 있다.

```
@class 클래스이름1, 클래스이름2, ..., 클래스이름n;
```

---

여러 개의 클래스를 **,(콤마)**로 이어서 쓸 수 있고, 마지막 클래스 이후에는 **;(세미콜론)**을 작성해야 한다.

클래스의 구현부에서는 헤더파일을 임포트 해야 해당하는 클래스의 메소드를 사용할 수 있다.

22.12.21 추가)

프로토콜 또한 **@protocol** 을 통해 전방 선언할 수 있다.

## **인스턴스 변수에 대한 접근**

인스턴스 변수에 대한 접근은 같은 클래스의 인스턴스에서만 가능하다. *(obj→val 의 형태)*

하지만 일반적으로는 인스턴스 변수에 직접 접근하지 않고, **대부분 접근을 위한 메소드를 따로 정의해서 사용**한다. (getter  / setter)

이로 인해서 객체를 보호하고 정보를 은닉할 수 있다. 이런 매커니즘을 좀 더 개선시켜서 사용하는 것이 **property**이다.

```

```

> ... 인스턴스 변수를 작성하는 것보다 proterty를 만드는 것이 더 일반적이다.
> 
> 
> *인스턴스 변수는 기본적으로 protected한 변수인데 이를 외부에서 접근하기 위해 **public 등으로 여는 것은 Obj-C에서 사실상 사용되지 않는다**고 한다.*
> 
> *따라서 getter나 setter의 사용이 필요한데, 이것을 매번 선언하고 구현하는 것을 피하기 위해 **property**라는 개념이 도입되었다.*
> 
> *@property를 통해 선언된 property에서 **자체적으로 접두어 _(언더스코어)가 붙은 인스턴스 변수가 생성**된다.*
> 
> *@synthesize를 통해 이 property와 인스턴스 변수를 연결 시켜줄 수 있는데 생략하면 자동으로 연결시켜 준다.*
> 
> ***@dynamic**을 사용하면 getter와 setter 중 원하는 것을 수동으로 작성해줄 수도 있다 ...*
> 
> *<이전 내용에서 발췌>*
> 

*22.12.21 추가)*

*property의 값을 수정할 때에는 언더스코어가 붙은 인스턴스를 직접 수정하면 strong / weak 관계가 원하는 대로 작동하지 않을 수 있다.*

*반대로 property의 값을 읽어 올 때에는 인스턴스를 직접 불러오는 것이 빠르므로 **property 값을 수정하고 인스턴스 값을 불러오는 것이 유리**하다고 볼 수 있다.*

### **참고) property의 선언**

아래와 같이 interface 아래에 선언할 수 있다.

```
@interface TVRemoteController : RemoteController

@property int channel;

@end
```

---

### **참고) property의 다양한 속성**

1. **getter** / **setter** : getter와 setter 메서드 이름을 직접 설정할 수 있다.
2. **readwrite** / **readonly** : getter와 setter를 모두 생성할 지, getter만 생성할 지 선택할 수 있다.
3. **atomic** / **nonatomic** : 멀티쓰레드 환경에서 동시에 이 property에 접근을 시도할 때 getter와 setter에 대한 lock을 걸어주는 것이 atomic (mutex를 보장하여 안정적이지만 성능 저하의 우려가 있으므로 필요 없을 경우 가 있다.)
    
    nonatomic으로 명시해 줄 필요
    
4. **strong** (retain) / **weak** / **unowned** (assign) / copy : 메모리 참조와 관련한 속성을 설정한다. (retain / assign 이 Obj-C가 MRC 시절부터 가지고 있던 키워드 같다. Swift와 혼동을 피하기 위해 strong / weak / unowned 로 통일하면 될 것 같다.)
    1. **strong** (**retain**) : Swift의 strong에 해당하며, 시킨다.
        
        Reference count를 증가
        
    2. **weak** : Swift의 weak에 해당하며, . 참조하던 객체가 메모리에서 해제되면 된다.
        
        Reference count를 증가시키지 않는다
        
        자동으로 nil이 할당
        
    3. **unowned** (**assign**) : Swift의 unowned에 해당하며, 고, 참조하던 객체가 메모리에서 가지고 있다.
        
        Reference count를 증가시키지 않
        
        해제되어도 주소를 그대로
        
5. **nonnull** / **nullable** : Swift의 을 비슷하게 옮겨온 개념으로 쓸 수 있다. nullable로 선언되면 nil 값을 담을 수 있고, 한다.
    
    optional
    
    nonnull로 선언된 property에 nil 값을 담으면 에러는 발생하지 않지만 경고가 발생
    

### **참고) Swift에서는 Obj-C와 다르게 기본적으로 nonatomic으로 작동하며, atomic을 별도로 지원하지도 않는다고 한다. (직접 구현해야 한다고 함)**

## **클래스 객체 (=팩토리)**

Obj-C에서는 **클래스 또한 일종의 객체**로 취급된다. 이 관점에서 클래스를 "**클래스 객체**" 또는 "**팩토리**"라고 일컫는다.

클래스 객체의 독자적인 메소드는 "**클래스 메소드**" 또는 "**팩토리 메소드**"라고 부르며, 인스턴스 메소드와 다르게 + 기호와 함께 작성 된다.

alloc 또한 NSObject 클래스의 클래스 메소드이다.

클래스 객체의 클래스는 Class이며, id 타입으로도 다룰 수 있다.

## **클래스 메소드 (=팩토리 메소드)**

인스턴스 메소드와 다르게 - 대신 **+ 기호**로 선언된다.

대부분 선언과 구현의 부분에서 거의 동일하다.

당연하게도 해당 클래스로 생성되는 인스턴스는 여러 개가 될 수 있기 때문에 **클래스 메소드에서 인스턴스 변수에 접근하는 것은 불가능**하다.

**self**를 사용하게 되면 **그 클래스 객체 자신**을 참조하는 것이 되고, **super**를 사용하면 **슈퍼클래스의 클래스 객체**를 참조할 수 있다.

## **클래스 변수**

Obj-C에서는 **클래스 변수가 따로 존재하지 않는다**. 대신 구현 파일 내에서 **static 정적 변수**를 선언해서 클래스 변수로 사용할 수 있다.

**단, 상속을 사용할 경우에는 서브 클래스에서 상위 클래스의 static 정적 변수에 접근할 수 없**으므로 설계 시에 고려해야 한다.

## **클래스 객체의 초기화**

인스턴스 객체의 초기화와 다르게 이미 실행 시점에 클래스 객체는 생성이 되어 있기 때문에 별도의 메시지를 보내는 것이 불가능하다.

따라서 필요 시, main 함수에서 초기화 메시지를 보내는 방법이 있는데 클래스 객체 내부의 정보에 대한 은닉성도 위배되고 유지보수도 쉽지 않기 때문에 권장되지 않는 방법인 것 같다.

## **이니셜라이저의 리턴 타입에 대해**

이니셜라이저의 리턴 타입으로 특정 클래스로 정적인 타입을 쓰면 상속 관계에서 초기화 과정에 이슈가 생길 수 있으므로 id로 리턴하라고 알려져 있다.

하지만 현재 **iOS팀 컨벤션**을 참고하면 **id 타입이 아닌 instancetype으로 리턴**하도록 약속되어 있기 때문에 **id** 타입과 **instancetype**의 차이점에 대해 알아 보았다.

id와 instancetype을 반환하는 이니셜라이저는 동일한 결과를 나타낸다.

> ... Objective-C convention is to write instancetype explicitly for all methods.
> 
> 
> *Note that you should replace **id** with **instancetype** for return values only, not elsewhere in your code.*
> 
> *Unlike **id** , the **instancetype** keyword can be used only as the result type in a method declaration ...*
> 
> *<[Apple Developer Document](https://developer.apple.com/library/archive/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html) 안에서 발췌>*
> 

애플 공식 문서를 참고해봐도 id 대신에 **instancetype으로 대체**하도록 언급하고 있다.

instancetype을 통해 반환된 객체는 **선언한 클래스의 인스턴스와 일치한 객체**이다.

```
// 공식 문서 예제를 변형한 코드
@interface MyObject : NSObject
+ (instancetype)factoryMethodA;
+ (id)factoryMethodB;
@end

@implementation MyObject
+ (instancetype)factoryMethodA { return [[[self class] alloc] init]; }
+ (id)factoryMethodB { return [[[self class] alloc] init]; }
@end

void main() {
    NSLog(@"%d", [[MyObject factoryMethodA] count]); // 리턴 타입은 "MyObject *"이며, 컴파일 시간에 에러 발생
    NSLog(@"%d", [[MyObject factoryMethodB] count]); // 리턴 타입은 "id"이며, 런타임 시간에 에러 발생
}
```

---

만약 instancetype을 통해 반환된 객체에서 사전에 선언되지 않은 인스턴스 메서드를 사용하면 **컴파일 시점에서 오류**가 날 것이다.

하지만 id를 통해 반환된 객체에서 메서드를 호출할 때, 어딘가에 존재하는 클래스의 메서드(ex. count)가 있으면 **컴파일 시점에서는 오류가 발생하지는 않는다**.

당연히 런타임에서는 해당 메서드가 존재하지 않으면 오류가 발생한다. 오류는 컴파일 시점에서 잡는 것이 유리하다.